import re

class InstructionType:
    IMPERATIVE = 'IS'
    DECLARATIVE = 'DL'
    ASSEMBLER_DIRECTIVE = 'AD'

class Symbol:
    def __init__(self, label, address=None):
        self.label = label
        self.address = address

class Opcode:
    def __init__(self, mnemonic, opcode, instr_type):
        self.mnemonic = mnemonic
        self.opcode = opcode
        self.type = instr_type

class PassOneAssembler:
    def __init__(self):
        self.opcode_table = {}
        self.symbol_table = {}
        self.literal_table = []
        self.pool_tab = []
        self.intermediate_code = []
        self.location_counter = 0
        self.register_table = {'AREG': 1, 'BREG': 2, 'CREG': 3, 'DREG': 4}
        self.condition_table = {'LT': 1, 'LE': 2, 'GT': 3, 'GE': 4, 'EQ': 5, 'NE': 6, 'ANY': 1}
        self.init_opcode_table()

    def init_opcode_table(self):
        self.opcode_table = {
            'START': Opcode('START', 1, InstructionType.ASSEMBLER_DIRECTIVE),
            'END': Opcode('END', 2, InstructionType.ASSEMBLER_DIRECTIVE),
            'ORIGIN': Opcode('ORIGIN', 3, InstructionType.ASSEMBLER_DIRECTIVE),
            'EQU': Opcode('EQU', 4, InstructionType.ASSEMBLER_DIRECTIVE),
            'LTORG': Opcode('LTORG', 5, InstructionType.ASSEMBLER_DIRECTIVE),
            'DC': Opcode('DC', 1, InstructionType.DECLARATIVE),
            'DS': Opcode('DS', 2, InstructionType.DECLARATIVE),
            'STOP': Opcode('STOP', 0, InstructionType.IMPERATIVE),
            'ADD': Opcode('ADD', 1, InstructionType.IMPERATIVE),
            'SUB': Opcode('SUB', 2, InstructionType.IMPERATIVE),
            'MULT': Opcode('MULT', 3, InstructionType.IMPERATIVE),
            'MOVER': Opcode('MOVER', 4, InstructionType.IMPERATIVE),
            'MOVEM': Opcode('MOVEM', 5, InstructionType.IMPERATIVE),
            'COMP': Opcode('COMP', 6, InstructionType.IMPERATIVE),
            'BC': Opcode('BC', 7, InstructionType.IMPERATIVE),
            'DIV': Opcode('DIV', 8, InstructionType.IMPERATIVE),
            'READ': Opcode('READ', 9, InstructionType.IMPERATIVE),
            'PRINT': Opcode('PRINT', 10, InstructionType.IMPERATIVE)
        }

    def process_line(self, line):
        line = line.strip().replace('лю', 'M')
        if not line or line.startswith(';'):
            return
        tokens = [token for token in re.split(r'[ ,]+', line) if token]
        if not tokens:
            return
        label = None
        mnemonic = None
        if tokens[0] not in self.opcode_table:
            label = tokens[0]
            tokens = tokens[1:]
            if label not in self.symbol_table:
                self.symbol_table[label] = Symbol(label, self.location_counter)
            else:
                if self.symbol_table[label].address is None:
                    self.symbol_table[label].address = self.location_counter
        if not tokens:
            return
        mnemonic = tokens[0]
        operands = tokens[1:]
        op = self.opcode_table.get(mnemonic)
        if not op:
            print(f"Error: Unknown mnemonic {mnemonic}")
            return
        operand1 = operands[0] if len(operands) > 0 else None
        operand2 = operands[1] if len(operands) > 1 else None
        if op.type == InstructionType.ASSEMBLER_DIRECTIVE:
            ic_operands = ""
            if mnemonic == 'START':
                self.location_counter = int(operand1)
                ic_operands = f" (C,{operand1})"
            elif mnemonic == 'ORIGIN':
                self.location_counter = self.evaluate_expression(operand1)
                ic_operands = f" (S,{operand1})"
            elif mnemonic == 'EQU' and label:
                self.symbol_table[label].address = self.evaluate_expression(operand1)
                return
            elif mnemonic == 'LTORG' or mnemonic == 'END':
                self.process_literals()
            ic = f"({op.type},{op.opcode}){ic_operands}"
            self.intermediate_code.append(ic)
            if mnemonic == 'END':
                return
        elif op.type == InstructionType.DECLARATIVE:
            if label:
                self.symbol_table[label].address = self.location_counter
            ic_val = ""
            if mnemonic == 'DC':
                self.location_counter += 1
                ic_val = f" (C,{operand1})"
            elif mnemonic == 'DS':
                size = int(operand1)
                self.location_counter += size
                ic_val = f" (C,{size})"
            ic = f"({op.type},{op.opcode}){ic_val}"
            self.intermediate_code.append(ic)
        elif op.type == InstructionType.IMPERATIVE:
            current_lc = self.location_counter
            if label:
                self.symbol_table[label].address = current_lc
            self.location_counter += 1
            ic = f"({op.type},{op.opcode})"
            if mnemonic == 'STOP':
                pass
            elif mnemonic == 'BC':
                ic += self.format_operand(operand1)
                ic += self.format_operand(operand2)
            elif mnemonic in ['READ', 'PRINT']:
                ic += self.format_operand(operand1)
            else:
                ic += self.format_operand(operand1)
                if operand2:
                    ic += self.format_operand(operand2)
            self.intermediate_code.append(ic)

    def format_operand(self, operand, first=False):
        operand = operand.strip().rstrip(',')
        if operand.startswith("='"):
            for idx, lit in enumerate(self.literal_table):
                if lit['literal'] == operand:
                    return f" (L,{idx+1})"
            self.literal_table.append({'literal': operand, 'address': None})
            return f" (L,{len(self.literal_table)})"
        elif operand in self.register_table:
            return f" (R,{self.register_table[operand]})"
        elif operand in self.condition_table:
            return f" (C,{self.condition_table[operand]})"
        elif operand.isdigit():
            return f" (C,{operand})"
        else:
            if operand not in self.symbol_table:
                self.symbol_table[operand] = Symbol(operand)
            return f" (S,{operand})"

    def process_literals(self):
        pool_start_index = -1
        for idx, lit in enumerate(self.literal_table):
            if lit['address'] is None:
                if pool_start_index == -1:
                    pool_start_index = idx + 1
                lit['address'] = self.location_counter
                self.location_counter += 1
        if pool_start_index != -1:
            self.pool_tab.append(pool_start_index)

    def evaluate_expression(self, expr):
        expr = expr.strip()
        if '+' in expr:
            base, offset = expr.split('+', 1)
            base_addr = self.symbol_table.get(base.strip(), Symbol(base.strip(), 0)).address or 0
            return base_addr + int(offset.strip())
        elif '-' in expr:
            base, offset = expr.split('-', 1)
            base_addr = self.symbol_table.get(base.strip(), Symbol(base.strip(), 0)).address or 0
            return base_addr - int(offset.strip())
        try:
            return int(expr)
        except ValueError:
            return self.symbol_table.get(expr, Symbol(expr, 0)).address or 0

    def run(self, filename):
        try:
            with open(filename, 'r', encoding='utf-8') as f:
                for line in f:
                    self.process_line(line)
        except FileNotFoundError:
            print(f"Error: Input file '{filename}' not found.")
            return
        print(f"\n --- Output for {filename} ---")
        print("\n INTERMEDIATE CODE ")
        for code in self.intermediate_code:
            print(code)
        print("\n SYMBOL TABLE ")
        for label, sym in self.symbol_table.items():
            print(f"{label}\t{sym.address}")
        print("\n LITERAL TABLE ")
        for i, lit in enumerate(self.literal_table):
            print(f"{i+1}\t{lit['literal']}\t{lit['address']}")
        print("\n POOLTAB ")
        for i, start_index in enumerate(self.pool_tab):
            print(f"Pool {i+1} -> Start Index {start_index}")

input_filename = "pass1_assembler/input2.asm"
assembler = PassOneAssembler()
assembler.run(input_filename)
